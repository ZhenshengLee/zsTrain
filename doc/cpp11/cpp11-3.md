# cpp11课程-3

并发编程

## 概念

### 什么是并发

并发： 单个处理器分时处理

并行： 多个处理器

为什么用并发： 关注点分离&性能

### c++98对并发看法

c++98不承认线程的存在，并且各个语言要素的操作效果都以顺序抽象机的形式编写；

### c++11

**在语言层面上支持，编写不依赖平台扩展的多线程代码**

直接使用标准库，编译器直接支持

## 线程管理

### join

简单粗暴等待线程结束，起100个线程帮我干活，干完后继续

### detach

后台执行，不等

### 线程间共享数据

线程间的问题，基本上都是共享数据的问题

### 避免恶性条件竞争（线程互斥问题）

#### 保护

上锁，信号量

#### 无锁

修改完的结构必须能完成一系列不可分割的变化（原子）

##### 死锁

鼓和鼓槌的问题

死锁的最大问题就是同时获取多个互斥量的问题。

- 避免嵌套锁
    - 一个线程已经获取一个锁时，别再取获取第二个
- 避免在持有锁时调用用户提供的代码
    - 用户程序可能做任何事情，包括获取锁
- 使用固定顺序获取锁

#### 事务

### 线程同步问题

线程等待一个事件（另一个线程完成或结束）

一个火车，在夜间，如何在规定时间下车

- 不睡，轮询
- 闹钟，提前15分钟
- 找一个列车员帮忙盯着

c++标准库模型提供很多手段

### 原子操作问题



### 线程访问内存的顺序问题（内存模型）

默认，顺序一致的。
修改代码，自旋等待。

顺序执行是最低效的内存模型。强顺序，低效。

不同CPU的内存模型，有可能不是强顺序执行。
这样编译器会在汇编处加上一个sync指令，内存栅栏，排空流水线。强制使得内存模型的顺序执行。

编译器也可以设置成不对执行顺序做任何保证
std::memory_order_relaxed，默认的是memory_order_seq_cst，全部按照顺序执行

## lambda表达式

匿名函数

```cpp
std::thread t([]{cout << "helloworld";});
```

## c++线程模型和Linux系统调用

又了解，又不要用

不要又不了解，又要用

遇见并发竞争问题

- 能不能够每个线程一份，不竞争资源
- 如果必须竞争，能不能够将竞争处理封装到内部，外部用户直接使用接口即可，将危险因素封装
-
