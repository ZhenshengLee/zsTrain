# cpp11课程-2

### 标准升级总的趋势

- C++代码会越来越安全
- 代码会越来越简单，程序员尽量关注业务逻辑，而不是语言特性
- 降低代码复杂度


### auto类型推导

是一种强类型的静态语言，用户编写代码必须去声明它，但是编译器是可以推导出来的，编译器还可以检查你声明的类型和初始化的类型一致不一致。

很多时候用户会弄混，所以用auto会比较省事儿

如果using namespace std; 会导致作用域扩散，
所以C++中的类型会很长，所以auto会很省事儿

在当前版本中，使用的方法是，使用typedef或者是#define宏定义，将一些类型用别名来表示
但是这种方法非常容易出错，用auto可以减少错误的发生。

宏定义满天飞

#### 使用纯C++编码

圆半径存储在list中，分别为1.5f, 1.6f,1.7f，求其周长存储在另一个List中，打印出来。

#### auto注意事项

auto只能用于赋值语句的类型推导，不能用于变量声明
auto允许使用const volatile & *
如果初始化表达是引用，则去除引用语义
如果初始化表达有const volatile，则去除
如果auto带上&，则不去除const
auto&&总是推断出引用类型


### for循环的改进

#### 老的

使用迭代器，查询是否到界。
代码一复杂，就一定会有问题，做得多，错的多。

#### 标准库的for_each

#### 简便的for循环，结合auto

只是一个语法糖，本质上还是使用迭代器来实现

#### 迭代器失效问题

### 强类型枚举

传统情况下，枚举直接当整型，或者常量用

```cpp
enum Weight{General, Heavy, Light};
enum Size{General, Heavy, Light};
// 会产生冲突，名字一样
// 使用命名空间，匿名命名空间是全局命名空间
```


#### C++11情况下

为了增加安全性，通过enum class/struct 的形式声明强类型的枚举，无法被隐式转换成整数，必须**使用类型名限定访问枚举值**，就像类的静态成员一样。

- 为了优化内存，允许自定义类型，比如用char来定义枚举

enum class EnumChar:char{X, Y, Z};

### 指针空值

一般是用NULL, 或者用void*
```#define NULL 0```

#### nullptr_t

nullptr_t明确的表示空指针概念，可以隐式转换为任意类型的指针，也可以与指针进行比较运算，不能转化为其他类型，不是int 或者 void*

### 数据对齐

不同硬件平台对存储空间的处理存在很大的不同，如果不按照平台要求对齐数据，会对效率产生很大影响。
如果一个32位的数据没有存放在4字节整除的地址，那么处理器就需要2个总线周期对其进行访问，因为数据占了两段

#### 一般用Pack

#### cpp11

```cpp
struct alignas(32) ColorVector
{};
```

### 移动语义

早期C++里面只有左值，c++11引入了新的“右值”

左值是放在=左边的，是一个函数或者对象实例，失效值是一个生命期即将结束的对象，广义左值包括左值和失效值

右值包括失效值，临时对象，

#### 右值引用T&&（右值别名）

右值往往很快就会释放，但是使用右值引用可以延长该右值的生命周期

#### move()转移对象

把一个对象明确地转换为“匿名”的右值引用，也就是说改对象确认是右值对象，可以被安全的。

#### 例子：深拷贝

类的拷贝构造函数写法

本来可以指针赋值

用右值引用会更好

本来是把临时对象拷贝过来，现在的情况是延长这个对象的声明周期，直接使用这个临时对象。

### 数据对齐和字节序

数据对齐和字节序都有两个方面：内存存储和数据传输




个人PC一般是小端，网络传输字节序一般是大端，PPC一般是大端，通信嵌入式设备一般是大端，但由于开源趋势，往往都是在个人PC上应用，所以小端越来越流行。
