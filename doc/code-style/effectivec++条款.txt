第一章 从C转向C++

条款1：尽量用const和inline而不用#define
条款2：尽量用而不用
条款3：尽量用new和delete而不用malloc和free
条款4：尽量使用c++风格的注释

第二章 内存管理
 
条款5：对应的new和delete要采用相同的形式
条款6：析构函数里对指针成员调用delete
条款7：预先准备好内存不够的情况
条款8: 写operator new和operator delete时要遵循常规
条款9: 避免隐藏标准形式的new
条款10: 如果写了operator new就要同时写operator delete
 
第三章 构造函数，析构函数和赋值操作符

条款11: 为需要动态分配内存的类声明一个拷贝构造函数和一个赋值操作符
条款12: 尽量使用初始化而不要在构造函数里赋值
条款13: 初始化列表中成员列出的顺序和它们在类中声明的顺序相同
条款14: 确定基类有虚析构函数
条款15: 让operator=返回*this的引用
条款16: 在operator=中对所有数据成员赋值
条款17: 在operator=中检查给自己赋值的情况
 
第四章 类和函数：设计与声明

条款18: 争取使类的接口完整并且最小
条款19: 分清成员函数，非成员函数和友元函数
条款20: 避免public接口出现数据成员
条款21: 尽可能使用const
条款22: 尽量用“传引用”而不用“传值”
条款23: 必须返回一个对象时不要试图返回一个引用
条款24: 在函数重载和设定参数缺省值间慎重选择
条款25: 避免对指针和数字类型重载
条款26: 当心潜在的二义性
条款27: 如果不想使用隐式生成的函数就要显式地禁止它
条款28: 划分全局名字空间
 
第五章 类和函数: 实现

条款29: 避免返回内部数据的句柄
条款30: 避免这样的成员函数：其返回值是指向成员的非const指针或引用，但成员的访问级比这个函数要低
条款31: 千万不要返回局部对象的引用，也不要返回函数内部用new初始化的指针的引用
条款32: 尽可能地推迟变量的定义
条款33: 明智地使用内联
条款34: 将文件间的编译依赖性降至最低
 
第六章 继承和面向对象设计

条款35: 使公有继承体现 "是一个" 的含义
条款36: 区分接口继承和实现继承
条款37: 决不要重新定义继承而来的非虚函数
条款38: 决不要重新定义继承而来的缺省参数值
条款39: 避免 "向下转换" 继承层次
条款40: 通过分层来体现 "有一个" 或 "用...来实现"
条款41: 区分继承和模板
条款42: 明智地使用私有继承
条款43: 明智地使用多继承
条款44: 说你想说的；理解你所说的
 
第七章 杂项

条款45: 弄清C++在幕后为你所写、所调用的函数
条款46: 宁可编译和链接时出错，也不要运行时出错
条款47: 确保非局部静态对象在使用前被初始化
条款48: 重视编译器警告
条款49: 熟悉标准库
条款50: 提高对C++的认识